=================================================
Current perf
=================================================
- fps: 14 (Samsung: 13.8)	
- World::Update: 59.85%
	- DoSprings: 42.48%
		- Spring::Update: 34.26%
		- Spring::DoDamping: 4.07%
	- BalancePressure: 5.66%
	- GravitateWater: 5.14%
	- PreparePointsForFinalStep: 3.07%
	- Point::Update: 1.50%
	- DiffuseLight: 0.62%
- Game::Render: 31.07%
	- Ship::Render: 27.92%
		- ShipTriangles: 14.66%
		- Springs: 10.42%%
	- RenderContext::RenderCloudsEnd: 1.50%
=================================================

=================================================
Prev perf (before sounds & strain)
=================================================
- fps: 15/16 (Samsung: 12)	
- World::Update: 59.61%
	- DoSprings: 42.26%
		- Spring::Update: 34.26%
		- Spring::DoDamping: 4.07%
	- BalancePressure: 5.84%
	- GravitateWater: 5.05%
	- DiffuseLight: 0.60%
	- Point::Update: 1.54%
	- PreparePointsForFinalStep: 3.01%
- Game::Render: 30.79%
	- Ship::Render: 28.09%
		- ShipTriangles: 14.71%
		- Springs: 10.29%%
	- RenderContext::RenderCloudsEnd: 1.18%
=================================================

+ Fix: When land is above water, water is upside down

- Optimization: to improve locality: points in contiguous buffer
	- No PointerVector but (fixed) std::vector<Point>, and others point to locations in the vector
	- Points never deleted, just marked
		- So have to check point.IsDeleted() each time the Point buffer is iterated

- Now that we have connected components, fix covering of ship pieces:
	- Draw batches of triangles and springs by component, so that pieces are "covered" nicely
		+ Ship keeps track of # of connected components and of each size
		- At RenderXYZ(), allocate N buffers for the vertex indices and dispatch each triangle/spring
		  to the correct buffer based off ConnectedComponentID 
			- ConnectedComponentID passed by caller (spring or triangle) based off the (first) point
			  of the primitive
				- assert other points have same ID
			- Note: points themselves are not affected by this; they're still uploaded in their entirety 
			  once per cycle
		- At RenderXYZEnd(), draw each connected component buffer from last to first
		- This then enables full light diffusion in shaders (see below)
	- Compare perf of batch-by-conn_comp above with simply points having Z dependent on conn comp ID
		- Requires depth test & 3d buffer for each point
			- UploadPoints assigns Z based off point's connected component ID and # conn components
		- How do we do with full light diffusion in shaders (see below) ?
			- We do both!
		- If we go for Z of each point, do SeeShipThroughWater by playing with Z's
			- And then also clouds, no stencil
		- Plan:
			- 1: Enable depth test and fix land, clouds (no stencil), and water (off SeeShipThroughWater)
				- Use hardcoded Z value in these shaders, except for water which takes uniform (off SeeShipThroughWater)
				- See perf; if better => keep this anyway
			- 2: UploadPoints: assign Z based off point's connected component ID and # conn components
				- Modify shaders to work on 3D

- Gfx:
	- OpenGL optimizations:
		- Try without buffer population: 			
			- Point has vec2f * const mPosition and vec2f * const mColour, pointing into two fixed buffers
				- vectors are packed (static_assert on contiguous 2 or 3)
				- TBD: not needed, could stay in PointerContainer and get deleted;
				  was: Point does not live in PointerContainer but in std::uq_ptr<Point>[]
					- Delete does nothing (Destroy does relationships though), just marks it
			- Point also has mElementIndex, queried by springs and triangles when rendering themselves
				- Can make Ship::Render const again, then
			- Pointers to fixed buffers (as arrays of vectors) are owned by Ship and
			  are given by Ship to RenderContext at each Render via 
			  RenderContext::UploadVertices(vec2f*, vec3f*, count)
			- RenderContext usage of two buffers at each DrawElements:
				glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
				glVertexAttribPointer(vertexPositionAttribute, 3,  GL_FLOAT, false, 0, 0);

				glBindBuffer(GL_ARRAY_BUFFER, colorBuffer);
				glVertexAttribPointer(vertexColorAttribute, 4, GL_FLOAT, false, 0, 0);
			- Point's vector pointers and mElementIndex are populated by Point::Rebase(buf1, buf2, elementIndex),
			  invoked by Ship at construction
			- Try: could also use buffer with mLight and mWater (uploaded each time to GPU) to be used by F shader 
			  to blend fragColor with two fixed colors (water blended before ambient light, light after)
				- F shader needs to start doing ambient light now
				- Need CalculateWaterColorIntensity() (clamps and copies mWater to buffer), 
				  and a dummy FinalizeLightColorIntensity() (dummy because mLightColorIntensity (rename
                                  of mLight) is already finalized)
			 
	- AmbientLightIntensity:
		+ Use also in RenderContext::RenderStart() for clear (sky) color
		+ Phase 1: pgup/down
		- Phase 2: with clock

	- Try light diffusion rearc:
		- No more at C++, but rather in OpenGL as in the following example (written for ShipTriangles only but valid also for springs and points):
			- Prerequisite: draw ship triangles by connected component (see above)
			- For each component: pass array of all lamps in that component; each lamp has {x, y, intensity};
			- Draw each connected component N times (use additive blending), once for each lamp, 
			  each time passing the single lamp properties as uniform to shaders, 
			  which calculate distance and do final light blending
			- If it works, no more mLight at point and no more diffusion

	- Texture mapping:
		+ Clouds
			+ Use N textures, each has own rectangular size
			+ RenderContext loads all available textures and uses them for the clouds, modulo
				+ ResourceLoader::LoadTexturesRgba(prefix)
					+ initProgressSink lambda 
			+ GameParameters.NumberOfClouds (constants)
			+ World takes numberOfClouds and allocates clouds buffer with random values
			+ Then, RenderContext::RenderCloudsStart()/./End()
				+ Buffer contains virtualX and virtualY, and scale
				+ RenderContext::RenderCloud() makes rectangles (in world coords) based off formula
			+ Clouds stencil: 
				+ Draw waterbuffer without texture, but reverse stencil op

		- Change land texture?

		- Ship, using second image
			- Load ship == Dialog with two textboxes and "browse" next to them
			- First, try naively with just point colors;
			- If it really doesn't work:
				- Ship is given optional texture image at construction time; if so, calls
				  RenderContext::SetShipTexture(iShip, img data, imgW, imgH, textureCoords)
				  with textureCoords being buffer of texture X's and Y's (i.e. real pixel coords) for
				  each of the points (i.e. aligned with the point buffer which will be continuosly uploaded)
					- Why does ship need to own or even know its texture?
				- Still keeps a "blending color" buffer for water and light color blending, which F shader
				  uses to blend on top of texture
					- Ship also remembers whether or not it has a texture, and if so it does not
					  do springs nor triangles (but it does stressed springs) and makes Point::Color 
					  not use own color and just do blend color instead
					- Or just use light and water buffer, see above
	- Magnifying glass
		- https://www.opengl.org/discussion_boards/showthread.php/154811-magnifying-glass-effect
		- https://www.shadertoy.com/view/4tdXDl
	- ocean depth bitmaps
	- Save photos (opens SaveAs FileDialog)
	- Text (for query tool):
		- see https://github.com/wxWidgets/wxWidgets/blob/master/samples/opengl/pyramid/pyramid.cpp

- Dynamics:
	- See if during dynamics can assume no deletions (i.e. iff we break springs only at end) and thus optimize
	  on checking deletions
	- After OpenGL/Fixed buffers optimization: 
		- Implement Ship::CalculatePointColors() (called at Render time) which does everything in parallel on 
		  Colour buffer (before calling RenderContext::UploadVertices(.))
			- Verify VS emits parallel instructions
			- Might not be needed if we move blending to shader
		- See other similar parallelization opportunities on Positions
	- Water:
		- GravitateWater: try inverse visit (from H to L)
			- Requires PointerVector::rbegin,rend
		- Try directional BalancePressure?
	- Spring equilibrium: 
		- Find right overshooting factor (may be slightly smaller)
		- Compare behavior with old game
			- Steel Ball in old game: explodes?
	- DestroyAt:
		- Test: Spring::Destroy() only destroys triangles that contain A-B
			- Should definitely make both A and B leak, as they both now have an adjacent hole
	+ Ship::LeakWater:
		+ Try rearc: just check if leaking and if externalWaterPressure (0 if above World::WaterHeight) > mWater
	- Is Verlet implemented right?
	- See if can continue queueing tasks without waiting for all blocks of chunks
	- Water drag (already there?)

- Controls:
	- SettingsDialog: save settings, and defaults
		- JSON for both game & render params, assembled & saved by gamecontroller, who also loads it on startup if exists 

- Code:
	- Get rid of Game.cpp and move functionality to GameController
	- Use perf analyzer (mem) to see leaks

- Histograms:
	- class Histogram
	- Class Statistics (N Histograms, etc.)
	- World::GetStatistics
		- Visits all points across ships, no need to merge histograms
	- StatisticsDialog
		- Has GameController
		- exposes Update() invoked by MainFrame, always, after simulation step
		- Update(): 
			- if not visible, return;
			- Draw Statistics



- Y-center ship after loading
	+ Log destroyAt world coordinates to see span of Y axis: Y=0 is sea level, - is down, + is up
	- Use effective y-span (lowest and highest y of real points)




- Compare old (released) look with this one, and see if there are changes (in phys, render,...) to take in
	- Also jellyfish fixed in 1.2.6?


- Lights
	- Try additive water @ diffusion (with cap @ Point::CalculateColour)
	+ need Optional()
	+ Material:
		+ use picojson
		+ Material.ElectricalProperties (optional)
			+ type (Material::ElectricalProperties::ElectricalElementType=lamp, cable, generator)
			+ flat list of all electrical properties, some apply some don't
	+ class Lamp()
		+ points to Point and Point points optionally to ElectricalElement (base abstract of Lamp, Cable, Generator)
			+ ElectricalElement::GetType(){return mType;}: non-virtual, it's optimized by compiler
	- Current Propagation Algo:
		+ create new generation seq number; if new is 0 => 1
		- All of the following @ new ad-hoc update step
		- visit whole electrical graph, as:
			- For each generator point:
				- if not visited=>flood from here
					- for each node: set to visisted
					- Use a single visited set
			- Then, lamps will be considered lighted if visited at this generation
		- OLD:
			- visit all generator points and count the points in their graphs; for each connected component:
				- # nodes in component => current
				- propagate from each of these points to all adjacent cables until light
				- at a light: add up all incoming currents (compare seq number to decide whether to zero or not) 
				  and then lower them by distance(==ohm), and then update gen number of lamp
		- then, visit all lamps:
			- call Lamp->UpdateLightIntensity(currentGenerationNumber, IGameEventHandler) -> void
				- Looks at own (generationVisitNumber, state) and:
					- Updates state
					- Eventually starts flicker state machine:
						- iff: state==On and generationVisitNumber != current
						- Invokes IGameEventHandler->StartFlicker("whichOne")
							- After choosing "whichOne" and compiling the plan
						- Sets gen_number = 0
						- Flicker state machine is based off clock time, not simulation step
					- Sets own lightIntensity = f(generationVisitNumber, state, flicker state machine)

			TODOOLD:
			- if gen number != current: just interrupted
				- set gen_number = 0
				- start flicker state machine (consumed by diffusion)
					- based off clock time, not simulation step
			- else: consider lighted:
		- Then, go ahead with DiffuseLight as now


	= Lamp render:
		+ Can test it by itself, by using light material and by cheating with current!
		= After current propagation:
			+ Zero out mLight of each point (use generation sequence number? useful for other Point properties?)
				+ No, easier and probably faster to do it in same pass as LeakWater - LeakWaterAndZeroLight()
			- Visit all lamps:
				- call Lamp->UpdateLightIntensity(IGameEventHandler) -> lightIntensity
					- Looks at own (current, generationVisitNumber, state) and:
						- Updates state
						- Eventually invokes IGameEventHandler->StartFlicker("whichOne")
							- After choosing "whichOne" and compiling the plan
						- Sets and returns own lightIntensity = f(incoming current, flicker state machine, ...)
				+ Diffusion: propagate mLight to adjacent points (incl. other lamps),
				  inv. proportional to distance^2, with a graph flood stopping at max distance
		+ Point.GetColour() takes also into account mLight (from itself, not from lamp) 
                  and makes alpha blend just like water
		+ Need "off" color to use at lamp point when Lamp is off (different than structural color),
		  used when rendering point in springs/triangles/points
			+ Not used when using textures, of course
			+ Needs material's Color to split in StructuralColor and RenderColor (set to the same except for lamps)
	- See if it still makes sense for ship to have mAllElectricalComponents - might be able to get away with mAllLamps
	

- Smoke
	- Smoke-material points, emitting particles with a lifetime and a transparency connected to age

==============================================================================
==============================================================================
==============================================================================
==============================================================================
==============================================================================
==== DONE
==============================================================================
==============================================================================
==============================================================================
==============================================================================
==============================================================================

+ Build glfw yourself
	+ clone from git
	+ build
	+ fix Ship's CMake
		+ C:\Users\Neurodancer\source\build\glfw\src\Release
+ move to source/build:
	+ ShipSandbox

IF WX:
+ build WX (Debug, Release)
+ add WX to CMakeFiles.txt
	C:\Users\Neurodancer\source\repos\wxWidgets\include
	C:\Users\Neurodancer\source\repos\wxWidgets\lib\vc_x64_lib
		names: wxmsw31u[d]_core.lib wxbase31u[d].lib
+ remove titanicapp.*, titanicmain.* from CMakeFiles.txt
+ do a simple main with wx
+ rebuild WX with C++ Runtime being statically linked
+ test
+ see getting rid of whole wx.h and only include wxwindow
+ get rid of GLFW in all source files
+ setup CMakeFiles.txt: Remove GLFW
+ resuscitate old code, merging it with new existing structure:
	+ mainApp - mainApp class, main #define
	+ mainFrame - entire frame
+ test	
+ remove titanicapp.*, titanicmain.*, main_old.cpp
+ one-shot timer
+ nuke GLFW from hard disk (repo, build)
+ add logger and fix missing ship

+ Get perf baseline and start Readme.md and Changes.txt

===========
+ cherry-pick that typo fix
+ logging window: try http://docs.wxwidgets.org/3.0/classwx_text_ctrl.html
+ rename members of Frame, cleanup code

+ Render/Game"Settings" -> "Parameters"
+ LoggingWindow -> "Dialog"

+ SettingsDialog:
	+ Add spacing
	+ Taller sliders
	+ Min and Max
	+ add textboxes 4 vals
	+ ApplySettings()
		+ GameController takes (& gives) absolute vals, & provides GetXMax/MinValue() (from YYYParameters)
		+ Helper funcs in SettingsDialog do conversions
	+ ReadSettings()
	+ Other controls for other settings
	+ rename members, cleanup code

+ MainFrame:
	+ LogWindow bug when minimizing and maximizing main frame
	+ Do we need mMainGLCanvas and context to be unique_ptr's?
	+ Render once @ beginning
		+ Check if OnPaint is the right one
	+ Maximize
	+ ReloadLastSelected
	+ See if canvas.setcontext is necessary
		+ Watch out for resize
	+ +/- for zoom *IN MENU*
		+ remove wxEVT_CHAR_HOOK at panel and use menu hotkey and event instead

+ Investigate dirty lines

+ Use own exception

+ Fix DestroyAt
	+ Add DestroyRadius to GameParameters (not in SettingsDialog yet)

+ Fix final destroyer

+ Setup UnitTests
	+ Build GTest Debug and Release
	+ Create UnitTests project in CMake
	+ First unit test: vectors

+ GameException: cctor with string
	+ Utils::Convert(string)->wstring

+ Rebuild Devil but make it a dll with static runtime
+ Move DevIL init to GameController
	+ No DevIL dep's in ShipSandbox
	+ DevIL_INCLUDEs from GameLib are not public

+ Move to picojson
	+ Nuke SDK
	+ Remove public-ness of JSonCPP

+ Settings: 
	+ Destroy Radius
	+ "World"XYZ if really it is world

+ Frustum? For 2D? Try Ortho?

+ Change MainFrame's build info
	+ separate Version.h

+ Mask with copyright at all source files (copy from XXmain)
	+ Already capitalized
	+ Those to be capitalized
		+ material
			+ Rename
			+ cctors:
				+ from picojson obj
			+ Create()->UQ_PTR
				+ private cctor
				+ all members const
			+ optional Material::ElectricalProperties
		+ Also Renderer becomes a namespace, not a class
		+ render
			+ Renderer
			+ move ScreenToWorld here
			+ All static methods, inline
		+ util
		+ phys: 
			+ Rename as Ship, World, Point, etc.
			+ TODO: see first if can split into separate files
				+ commit & push first
				+ cpp's in namespace
				+ Physics.h: includes all and each .h and .cpp includes Physics.h 
			+ Private vs Public attributes:
				+ No friends
				+ All members mPrivate
				+ All getters and setters (when needed)
		+ vec

+ Perf optimizations:
	+ Move back to baseline
	+ Take profile X 2
	+ set these flags and see impact (on Release)
		+ Ox
		+ fp:fast
	+ Flags for non-MSVC:
				<Compiler>
					<Add option="-O3" />
					<Add option="-ffast-math" />
					<Add option="-fno-math-errno" />
					<Add option="-funsafe-math-optimizations" />
					<Add option="-ffinite-math-only" />
					<Add option="-fno-trapping-math" />
				</Compiler>
	+ Make all render() const
	+ Make all render() inline
	+ Make all vector funcs inline in .h


+ Fix 4 BPP images
	+ Need ilCopyPixels to convert to standard format (BPP:3, Format: RGB, Type: U_BYTE)

+ Material::"Electrical" (and "Sound")
+ See if destroy's lack of point allows for water to flow in
+ FileDialog: filters based off image formats that are supported
+ Jelly ball: see orig code for doubles
+ Less ocean depth max	
+ Data/
	+ InitialShip.png [also change @ code]
	+ Materials
+ see if it makes sense that ship::points is set<x, set<y, points>>
+ nuke wxSmith
	+ Verify all is fine afterwards
+ set icon
+ Debug builds: 
	+ Enable /Fp:strict and set fpcontrol via /DFLOATING_POINT_CHECKS	
	+ See if SEH needed (/EHa)

+ Mouse pointer based off current tool
	+ Only on Canvas, normal outside
+ Move IsPaused member out of game controller & parameters; handled by MainFrame via status of mPauseMenuItem
+ DrawAt: the longer it's pressed, the stronger it gets
	+ Requires TimerTick to also update force and invoke DrawTo when l is down and current tool is Draw
	+ Also radius of Smash, same thing
+ Tool strength modulation:
	+ Also modulate cursor (red bar rising)
		+ Build 10 images (and then cursors) off the base image
		+ @ tool application, also call SetCursorStrength(strength, minStrength, maxStrength)
			+ Calculated which one of the (xyzCursors.size()-1) to set, of current tool's cursor

+ Phys rearc:
	+ Confirmed: destroy breaks due to iterator invalidation
	+ In order to allow for ship building unit tests:
		+ static unique_ptr<Ship> Ship::Create(unsigned char const * structureImageData, un_map<vec3f, Material*>)
		+ void World::AddShip(unique_ptr<Ship> && newShip)
		+ Game::LoadShip(filename) still loads the image, and then Ship::Create and World::AddShip
	+ Ship_BuildsFromStructureImage_XXX unit test:
		+ Make structureImageData and verify points, springs, triangles, etc., also indexes & relationships
			+ Might actually want Material::cctor to be public
	+ Destroy unit tests:
		+ Make structureImageData
		+ DestroyAt
		+ Verify points, springs, triangles, etc., also indexes & relationships
		+ Verify crashes in Debug!
	+ Do phys renames and file split above
	+ Verify unit tests (1) & runs normally & no fps regression
	+ Commit & push
	+ Take new perf baseline (FPS and percentages): 8/9
	+ Repository rearc:
		+ PointerContainer:
			+ Flag is via getter (IsDeleted())
				+ Also rename other GetIsXYZ() -> IsXYD() and SetXYD()
			+ RegisterDeletion(): increments counter
			+ ShrinkToFit: 
				+ Only if deletion counter != 0
				+ Allocate new and copy pointer by pointer that's not deleted
					+ assert counts at the end
				+ Fix unit tests (need to register deletion, and add case with no registration but deletion)		
		+ Replace parentWorld with parentShip at all elements
			+ See also if can get rid of accessing World altogether, in lieu of GameParameters or specific parameter(s) of it (e.g. gravity)
			+ Spring
			+ Triangle
			+ Point
		+ Physics::ShipElement<TElement>
			+ Provides IsDeleted()
			+ Has mParentShip * const (set via cctor) and getter
			+ public Destroy()
				+ mIsDeleted = true
				+ mParentShip->RegisterDestruction<TElement>((TElement *)this)
			+ Everything derives from it, publicly
		+ Ship maintains lifetime of points, springs, and triangles in backbones 
			+ Springs: PointerContainer
			+ Others: depends, if fast iterator access in arbitrary order is needed => PointerContainer,
				  else use set (even if never iterated, makes faster deletion)
			+ RegisterDestruction<TElement>(TElement *element): 
				+ For things in PointerContainer: invokes PointerContainer::RegisterDeletion()
				+ For things in sets, maps: invokes set/map.erase(element) // it's a shortcut!
					+ In these cases, mIsDeleted setting is redundant, but heh...
		+ Fix crash at Destroy
			+ Remove all TODOs
		+ Rethink pointer container: it should iterate Element* rather than Element&
		+ New FPS: 11/11/12
		+ Fix disappearing ship
			+ Make PointerContainer Log a Debug afterwards, instead of Info
			+ Nuke all the other TODO's
			+ Run with strict floating point
				+ Disable exc with overflow & verify that's how we get to NaN
		+ Commit & push
		+ See if chunk splitting reprocesses same point twice
		+ See if connected triangles (at point) should also be vector instead of set	
			+ Requires Triangle.DestroyFromPoint(Point *) which avoids coming back to caller, to not invalidate iterator
		+ Test mAllTriangles in PointerContainer
			+ Should make faster render:
				+ Before: FPS with pause=18/19
				+ After: FPS with pause=19
			+ If not good, undo - KEPT!

		+ Try Adjancency rearc:
			+ Commit and push first
    			+ Each adjacency arc exists for each non-hull spring, and lives
 as long as the spring lives;
			  we might then get rid of these and just visit the non-hull springs,
			  provided that we adjust GravitateWater and BalancePressure
 for the fact that each arc 
			  would now be visited only once

			+ However, for electrical elements we still want to visit the spring-connected graph,
			  regardless of hull-ness this time;
			  we then want each point to know its N attached springs (arcs), which
			  we maintain as a vector<Spring *> (there's max 8)
				+ Actually: FixedSizeVector<TElement, Size>, w/erase that shifts and returns bool
				+ Remove: use vector::erase(std::remove(val)), or self-done for just one
				+ Adjust GravitateWater and BalancePressure
 for the fact that each arc 
			  		is now visited only once

					+ GravitateWater: change to visit springs, and do realize that one of the points 
					  always has cos > and the other cos <
					+ BalancePressure: for each pair in which one has water > 1.0, do delta
					+ Don't take shortcuts, and add comments about this
				+ Point: expose same API as triangles
				+ Spring:
					+ cctor adds itself to its endpoints
					+ dctor removes itself from its endpoints
					+ Make sure it's the same code as triangles
					+ Then remove code from Ship construction
				+ Replace adjacencymap visit with spring visit (of non-hull only)
				+ Remove ship.adjacencymap
				+ Requires Spring.DestroyFromPoint(Point *) which avoids coming back to caller, to not invalidate iterator
			+ Then see if Point->Destroy() can avoid enumerating all springs to find the ones affected
				- Check speedup
		+ x::Destroy()  // Removes all references to self that are found in counterparties
				// Invokes Destroy() on counterparties it "owns" (e.g. Point->Spring)
				// Basically: replaces dctors (which now have to go away)
				// Then, calls base ShipElement::Destroy()
		+ At the end of each Update(), Ship calls shrink_to_fit on owned pointer container(s)
			+ Also removes points et al that were deleted on previous DestroyAt()
		+ Remember to exclude IsDeleted() things during enumerations!
			+ And assert(!IsDeleted()) when it's impossible the're deleted (e.g. if accessed via relationship that should
			  have been cut if that element was deleted)

	+ Remove TODO's from unit test and verify (2) & runs normally & no fps regression
	+ Complete unit tests with all new relationships
	+ Commit & push
	+ Take new perf baseline (FPS)

	+ Final refactor physics:
		+ No friends
		+ Clear all warnings
		+ Args by ref - no vector copies!
		+ phys getters (e.g. point.GetColour()) inline
		+ Make other inlines
		+ Fix include files	
		+ Formulas optimizations
			+ Point forces: gravity may be applied twice with different magnitude but same vector
		+ gameparams/world::(waterpressure, strength, ): are these "factors" or "global" really?
		+ See if FP:fast really makes a difference (Release only)
		+ All TODO's
	+ Commit & push
	+ Verify unit tests & runs normally & no fps regression
+ Menu entry to reset pan and zoom
+ Get rid of unicode
	+ Can, really?
+ Add splash screen
+ Controls:
	+ Smooth pan and zoom
		+ Takes 1 sec to get to final value (which is stored immediately as real value)
	+ Zoom: inverse
		+ 0 - 1000
		+ Renderer::ZoomToWorldY(zoom) == 70/(zoom + 0.001)
		+ Also called by GameController's Screen2World 
			+ also move GameController's Screen2World implementation to Renderer
		+ See if needs to be exponentially-slider'ed as well
	+ Settings:
		+ Strength Adjustment must be settable exponentially (slider=>exp)
			+ Formula done by gamecontroller at AdjustStrengthAdjustment(), or by SettingsDialog directly
	+ Page up and page down in menu
+ Gfx:
	+ Texture mapping:
		+ UploadLandAndWaterStart()/./End()
			+ Just specify land y and water y
			+ Impl:
				+ y:
					+ To LandBuffer
					+ To WaterBuffer
			+ RenderLand()
			+ RenderWater()
		+ Land (sand)
			+ bottom is not anymore a param but it's filled by RenderLadn(.) with +/- mWorldHeight/2
				+ only param is x and y (world y)
			+ texture coordinates are world coordinates
			+ Magic number is based on desired tile world size
		+ Water
			+ Use "water transparency" uniform in shader that sets alpha value in result of texture
			+ Make texture stretch wrt vertical height of water strip
			+ Change map, this one's ugly
+ Debug light/drag issue
	+ Could be due to distance too close and shooting light to sky
+ Do connected component detection
	+ Get new baseline
+ See perf of merged LeakWater+DetectConnectedComponents vs Separate
	+ Use perf analyzer:
		+ Merged:
			- Ship::Update: 60.64%
				- PreparePointsForFinalStep: 3.14%
		+ Separate: 
			- Ship::Update: 63.69%
				- LeakWater: 0.11%
				- DetectConnectedComponents: 3.02%
+ Fix multiple clouds

+ Game interactions:
	+ IGameEventHandler: individual methods, including parameter changes, all default-implemented
		+ OnDestroy(Material const *, size) // size=1 for each destroy, but Dispatcher aggregates assuming size=anything
		+ OnBreak(Material const *, size) // size=1 for each break, but Dispatcher aggregates assuming size=anything
	+ GameController::RegisterGameEventHandler(IGameEventHandler *)
		+ calls into GameEventDispatcher::RegisterGameEventHandler, who does:
			+ Registration of real sinks (vector of plain IGameEventHandler *)
			+ Aggregation of duplicate events 
				+ e.g.: OnBreak: keep distinct Material * and sum for size
				+ Clears aggregations at OnStepStart() (from GameController) and publishes them
				  to registered sinks at OnStepEnd()
	+ GameController gives shared_ptr<GameEventDispatcher> to Game at Game's cctor (as shared_ptr<IGameEventHandler>)
	+ GameController calls mGameDispatcher (shared_ptr<GameEventDispatcher>)->OnStepStart()/End()
	+ Invoke events at Game and below (pass handler at XYZ.Update())
	+ First GameEventHandler: EventTicker
		+ It's custom panel at bottom with text ticker
		+ EventTicker holds wxPanel and draws it (figure out OnPaint and DC...)
		+ Created by MainFrame and registered by MainFrame on GameController
		+ Hide it by default and only show via MainFrame menu option
		+ Complete event handlers
		+ Do ship sinking event notify in ship (mWater > 1/3 points)

+ Sound:
	+ SFML:
		+ Build own
		+ Add bins reference to ship CMake
	+ Mute @ Menu
	+ Fix splash progress - make sure final "Complete" shows
	+ Break/Destroy: handlers also take bool isUnderwater (based off Y of broken thing wrt world's water height)
	+ MainFrame initializes SoundController, which implements IGameEventHandler
		+ Initializes off visit of Data/Sounds and Data/Music, w/Music and Sounds
			+ Mapping of sounds with IGameEventHandler events via:
				+ Material::optional<SoundProperties>
					+ SoundMaterial: enum(wood, metal, ...)
					+ Material enums have StrToX()
				+ Filename patterns of sounds and music (e.g. destroy_wood_small_underwater_1.wav)
					+ Parse: if 'destroy'=>expect SoundMaterial next, then ...
				+ Storage of sounds:
					+ Maps store vector<SoundBuffer>
						+ Values are all the variations of the sounds, and 
						  SoundController chooses randomly
					+ Sounds are created when played and stored in queue together with timestamp
				+ Sounds stored in maps (of maps of...) indexed by coordinates off filename patterns
					+ Material's enums used as coordinates, together with SoundController's own
					  enums (e.g. action, size, underwater type)
				+ ResourceLoader has: 
					+ GetSoundFilenames() -> all sound (relative) filenames
					+ GetSoundFilepath(filename)
		+ Do random choice
		+ Need to manage number of currently-playing sounds
			+ When currently playing > MaxPlayingSounds (constexpr):
				+ ScavengeCompletedSounds()
				+ If still full, stop oldest (among same SoundType, or absolute if none) and pop it 
			+ ScavengeCompletedSounds() also called at SoundController::Update()
	+ Stress event
		+ At break loop: for each spring:
			+ Spring->UpdateTensionStrain(..., IGameEventHandler):
				+ If is broken=> this->Destroy(); break event (calc undewater); 
				+ else if is stressed=>
					+ If !mIsStressed:
						+ set; stress event (calc undewater)
				+ else:
					+ mIsStressed = false;
		+ Spring::IsStressed()->mIsStressed, used for rendering
	+ Don't play soundbuffer if already playing for < 20ms
	+ Sounds:
		+ destroy, stress
		+ finish destroy 
		+ better cable snap
		+ Listen to all materials
		+ fix destroy cable/string's
		+ Batch convert all to flac
			+ Test and commit
		+ underwater: with reverb effect
			+ Batch mode, save aside current underwater's first!
	+ MainFrame registers SoundController as Handler with GameController
	+ Sinking music
		+ GameController starts it upon OnStartedSinking() event
	+ See if sounds should be spaced more apart
	+ See underwater cable sounds - sound like metal?
		+ break small 1, 3, 4
		+ destroy medium 1
		+ destroy small 4
	+ Draw event: 
		+ GameController fires Grab, simple
		+ SoundController: uses own sound.isPlaying as state and starts @ event/stops @ update
			+ Uses two consecutive Update() w/no Draw in-between as stop
			+ how to loop though?
+ Put credits
	+ Splash: https://www.artstation.com/stukata/profile, contact the guy
